import { spawn } from "child_process";
export async function parsePdf(buf: Buffer): Promise<string>{
  try{ const pdf = await import("pdf-parse"); const out = await pdf.default(buf); const t = String(out.text||"").trim(); if(t) return t; }catch{}
  try{ const t = await runPdftotext(buf); if(t) return t; }catch{}
  try{ const t = await runOCR(buf); if(t) return t; }catch(e){ console.error("OCR failed:", (e as any)?.message || e); }
  throw new Error("No text found (scanned or protected PDF).");
}
function runPdftotext(buf: Buffer): Promise<string>{ const cmd = process.env.PDFTOTEXT_PATH || "pdftotext"; return new Promise((resolve,reject)=>{ const p = spawn(cmd, ["-layout","-","-"]); let out = "", err = ""; p.stdout.on("data", d=> out += d.toString("utf-8")); p.stderr.on("data", d=> err += d.toString("utf-8")); p.on("error", reject); p.on("close", code=> code===0 ? resolve(out.trim()) : reject(new Error(err||`pdftotext exit ${code}`))); p.stdin.write(buf); p.stdin.end(); }); }
function runOCR(buf: Buffer): Promise<string>{ return new Promise((resolve,reject)=>{ const ocrmypdf = process.env.OCRMYPDF_PATH || "ocrmypdf"; const { spawn } = require("child_process"); const os = require("os"); const path = require("path"); const fs = require("fs"); const tmpdir = fs.mkdtempSync(path.join(os.tmpdir(), "pau-")); const inPdf = path.join(tmpdir, "in.pdf"); const outPdf = path.join(tmpdir, "out.pdf"); fs.writeFileSync(inPdf, buf); const r = spawn(ocrmypdf, ["--deskew","--clean","--skip-text","--force-ocr", inPdf, outPdf]); let err = ""; r.stderr.on("data", d=> err += d.toString("utf-8")); r.on("close", (code:number)=>{ if(code!==0){ cleanup(); return reject(new Error(err||`ocr exit ${code}`)); } const cmd = process.env.PDFTOTEXT_PATH || "pdftotext"; const r2 = spawn(cmd, ["-layout", outPdf, "-"]); let out = "", err2=""; r2.stdout.on("data", d=> out += d.toString("utf-8")); r2.stderr.on("data", d=> err2 += d.toString("utf-8")); r2.on("close", (code2:number)=>{ cleanup(); if(code2!==0) return reject(new Error(err2||`pdftotext(ocr) exit ${code2}`)); resolve(out.trim()); }); }); function cleanup(){ try{ fs.rmSync(tmpdir, {recursive:true,force:true}); }catch{} } }); }
